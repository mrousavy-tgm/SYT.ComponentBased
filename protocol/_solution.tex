%!TEX root=../main.tex	% Optional

\section{Lösung}

\subsection{Vorbereitung}

Als Projekt wird eine \textbf{Java EE 8} Application mit folgenden Frameworks erstellt:
\begin{itemize}
    \item \textbf{Maven} - Package/Library Management System
    \item \textbf{Java Persistence API} - Annotation Declarations für Entities und das ORM System
    \item \textbf{Hibernate} - Die Implementierung von \gls{jpa}
    \item \textbf{\gls{jdbc}} - Java Datenbank Interface
    \item \textbf{log4j} - Java Logger API
\end{itemize}
\textbf{IntelliJ} lädt automatisch benötigte Libraries, andernfalls kann man dies manuell hinzufügen.

Maven wird bei dem Menüpunkt "Project Dependencies" ausgewählt.

Mittels Maven können nun alle Libraries hinzugefügt werden:

\begin{itemize}
    \item MySQL:
        \begin{code}{xml}
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>6.0.6</version>
        </dependency>
        \end{code}
    \item Hibernate (inklusive \gls{jpa}):
        \begin{code}{xml}
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-core</artifactId>
            <version>5.2.16.Final</version>
        </dependency>
        \end{code}
    \item log4j:
        \begin{code}{xml}
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>
        \end{code}
    \item XML Bind:
        \begin{code}{xml}
        <dependency>
            <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>
            <version>2.3.0</version>
        </dependency>
        \end{code}
\end{itemize}

Das \textbf{Maven} \gls{pom} sieht dementsprechend folgendermaßen aus:

\begin{code}{xml}
<!--pom.xml-->
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" >
    <modelVersion>4.0.0</modelVersion>

    <groupId>mrousavy</groupId>
    <artifactId>Westbahnhof</artifactId>
    <version>1.0</version>

    <dependencies>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>6.0.6</version>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-core</artifactId>
            <version>5.2.16.Final</version>
        </dependency>
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>
        <dependency>
            <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>
            <version>2.3.0</version>
        </dependency>
    </dependencies>
</project>
\end{code}

\subsection{Datenbank}

Als Datenbank habe ich mich für eine MySQL 5 Datenbank entschieden, welche in einem Docker \cite{wiki:docker} Container laufen wird.

Dazu habe ich mir eine Dockerfile \cite{docker:dockerfile} geschrieben, welche diesen angepassten MySQL Container zusammenbaut.

Das vollständige Dockerfile schaut dementsprechend folgendermaßen aus:

\begin{code}{Dockerfile}
FROM mysql:latest

ENV MYSQL_ROOT_PASSWORD=root

ENV MYSQL_DATA_DIR=/var/lib/mysql \
    MYSQL_RUN_DIR=/run/mysqld \
    MYSQL_LOG_DIR=/var/log/mysql

ADD ["db_dump.sql", "/tmp/dump.sql"]
COPY ./db_dump.sql /docker-entrypoint-initdb.d/

RUN /etc/init.d/mysql start && mysql -u root -p$\{MYSQL_ROOT_PASSWORD\} < /tmp/dump.sql

EXPOSE 3306
\end{code}

Wobei das \texttt{db\_dump.sql} Create-Script nur die Datenbank erstellt:

\begin{code}{sql}
DROP DATABASE IF EXISTS westbahn;
CREATE DATABASE westbahn;
USE westbahn;
\end{code}

\

Um den Container zu kompilieren verwende ich folgendes script:

\begin{code}{sh}
#!/bin/bash

docker stop mysql
docker rm mysql

docker build -t mysqlimg .
sleep 2
docker run -d --name mysql -v /home/mrousavy/Dockerfiles/data:/var/lib/mysql mysqlimg
\end{code}

Und gestartet kann er mit

\begin{code}{sh}
docker start mysql
\end{code}

werden. In meinem Fall ist die IP Addresse des Containers \texttt{172.17.0.2}.

\subsection{JPA Konfiguration}

Die \gls{jpa} (bzw. Hibernate) muss korrekt konfiguriert werden. Unter anderem muss die SQL Verbindung und der Typ festgelegt werden.

Die Konfigurations-Datei ist eine XML Datei, welche in den App-Resources gespeichert werden muss.

In meinem Fall ist das der relative Pfad: \texttt{src/main/resources/META-INF/persistence.xml}.

Der root tag dieser XML Datei ist ein \texttt{persistence} tag, in welchem die \texttt{persistence-unit} (mit dem \texttt{name} Attribut) definiert wird.

Diese \texttt{persistence-unit} hat verschiedene \texttt{property} tags, welche bestimmte Attribute in der \gls{jpa} konfigurieren.

\

Die vollständige \texttt{persistence.xml} Datei wird folgendermaßen definiert:

\begin{code}{xml}
<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
                version="2.0" >

    <persistence-unit name="westbahn" >
        <description>Westbahn Persistence Configuration XML file</description>
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>

        <properties>
            <!-- MySQL -->
            <property name="hibernate.connection.url" value="jdbc:mysql://172.17.0.2:3306/westbahn" />
            <property name="hibernate.connection.username" value="root" />
            <property name="hibernate.connection.password" value="root" />
            <property name="hibernate.connection.driver" value="com.mysql.jdbc.Driver" />
            <property name="hibernate.dialect" value="org.hibernate.dialect.MySQL5Dialect" />

            <property name="hibernate.hbm2ddl.auto" value="create"/>
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>
        </properties>
    </persistence-unit>
</persistence>
\end{code}


\subsection{Entities}

Entities sind einfache Klassen, bzw. \gls{pojo}, welche durch die \gls{jpa} auf die Datenbank \textit{gemapped} werden.

\

Für die Westbahn, müssen alle Entities in dem UML (Siehe: Figur~\ref{fig:uml}) implementiert werden.

Je \gls{entity} muss ein \gls{pojo} erstellt werden, welches eine von der \gls{jpa} verwaltete Schnittstelle zwischen dem Java Code und der Datenbank repräsentiert.

Die Entities habe ich aus dem Astah UML Diagramm exportiert: \textbf{Tool -> Java -> Export Java}

Astah hat nun alle Klassen aus dem UML Diagramm exportiert, welche aber noch alle \gls{jpa} \textbf{Annotations} erhalten werden.

\

\textbf{Annotations} sind Metadata informationen, welche zur Kompilierung (bei Ausnahmefällen: Auch zur Laufzeit) Klassen, Attributen oder Methoden hinzugefügt werden können.

Die wichtigste \textbf{Annotations} ist:
\begin{code}{java}
@Entity
public class Bahnhof {}
\end{code}

welche auf jedem \textit{gemappten} \gls{pojo} zu finden ist.

\

Außerdem sollte jede Entity eine eindeutige Identifikation haben, oft durch eine Ganzzahl mit dem namen \texttt{ID}.

Beispielsweise könnte so die ID von einem Bahnhof ausschauen:

\begin{code}{java}
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private long ID;
\end{code}

wobei die \textbf{Annotation} \texttt{@GeneratedValue} der \gls{jpa} mitteilt, es handelt sich um ein generiertes Attribut welches im Idealfall nicht vom Benutzer modifiziert wird. Beispielsweise wäre dies eine automatisch mitzählende Identifikation.

\

Alle anderen Attribute bzw. \textbf{Properties} können zusätzliche \textbf{Annotations} erhalten, sind jedoch optional. Beispielsweise kann ein name auch einzigartig sein:

\begin{code}{java}
@Column(unique = true)
private String name;
\end{code}

\

Mit etwas \gls{ide} Zauberei können auch getter und setter Methoden generiert werden, womit das \gls{pojo} - und nun auch die \gls{entity} - nun so ausschaut:

\begin{code}{java}
package BusinessObjects;

import javax.persistence.*;
import java.io.Serializable;

@Entity
public class Bahnhof {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private long ID;

	@Column(unique = true)
	private String name;

	private int absPreisEntfernung;

	private int absKmEntfernung;

	private int absZeitEntfernung;

	private boolean kopfBahnhof;

    public long getID() {
        return ID;
    }

    public void setID(long ID) {
        this.ID = ID;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAbsPreisEntfernung() {
        return absPreisEntfernung;
    }

    public void setAbsPreisEntfernung(int absPreisEntfernung) {
        this.absPreisEntfernung = absPreisEntfernung;
    }

    public int getAbsKmEntfernung() {
        return absKmEntfernung;
    }

    public void setAbsKmEntfernung(int absKmEntfernung) {
        this.absKmEntfernung = absKmEntfernung;
    }

    public int getAbsZeitEntfernung() {
        return absZeitEntfernung;
    }

    public void setAbsZeitEntfernung(int absZeitEntfernung) {
        this.absZeitEntfernung = absZeitEntfernung;
    }

    public boolean isKopfBahnhof() {
        return kopfBahnhof;
    }

    public void setKopfBahnhof(boolean kopfBahnhof) {
        this.kopfBahnhof = kopfBahnhof;
    }
}
\end{code}

\

Dementsprechend müssen nun alle \gls{pojo}s zu \textbf{Entities} gemacht werden.

\

Ein Sonderfall war die \gls{entity} Strecke (\texttt{Strecke.java}), da diese \textit{unique constraints} benötigte.

Dazu gefunden habe ich die Dokumentation in den Java Docs: \gls{uniqueConstraints}, welche zu folgendem Code für die \gls{entity} \textbf{Strecke} führte:

\begin{code}{java}
@Table(
        uniqueConstraints = @UniqueConstraint(columnNames = {"start_id", "ende_id"})
)
\end{code}
